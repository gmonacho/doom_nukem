  new_poly->next = *poly;
			printf("Equation %f x + %f y + %f z + %f = 0\n", poly->equation.v.x, poly->equation.v.y, poly->equation.v.z, poly->equation.d);
			printf("I %f %f %f\n", poly->i.x, poly->i.y, poly->i.z);
			printf("J %f %f %f\n", poly->j.x, poly->j.y, poly->j.z);
			printf("II JJ IJ IJIJ_IIJJ %f %f %f %f\n", poly->ii, poly->jj, poly->ij, poly->ijij_iijj);
			poly = poly->next;
		poly->texture = IMG_Load("textures/randomPNG/Brick.png");
		poly->texture = IMG_Load("textures/elephantride.png");
		poly->texture = IMG_Load("textures/plafond.png");
		poly->texture = IMG_Load("textures/vitre.png");
		poly->texture = IMG_Load("textures/mur_pierre.png");
	printf("new texture : %p\n", poly->texture);
	if (!is_null(poly->equation_rotz_only.v.x, 0.0005))
	return (is_in_poly(poly, fdot_3d_sub(c1, poly->dots[0]), fdot_3d_sub(c2, poly->dots[0])));
	if (!is_null(poly->equation_rotz_only.v.x, 0.0005))
		ad = -poly->equation_rotz_only.v.y / poly->equation_rotz_only.v.x;
		bd = -(poly->equation_rotz_only.v.z * zc + poly->equation_rotz_only.d) / poly->equation_rotz_only.v.x;
	else if (!is_null(poly->equation_rotz_only.v.y, 0.0005))
		ad = -poly->equation_rotz_only.v.x / poly->equation_rotz_only.v.y;
		bd = -(poly->equation_rotz_only.v.z * zc + poly->equation_rotz_only.d) / poly->equation_rotz_only.v.y;
		if (!(poly->dots_rotz_only[0].z < -player->height / 2 || player->height / 2 < poly->dots_rotz_only[0].z) &&\
			(is_in_poly(poly, fdot_3d_sub((t_fdot_3d){0, 0, poly->dots_rotz_only[0].z}, poly->dots_rotz_only[0]),\
							fdot_3d_sub((t_fdot_3d){0, 0, poly->dots_rotz_only[0].z}, poly->dots_rotz_only[0])) ||\
			// (is_in_poly(poly, (t_fdot_3d){0, 0, poly->dots_rotz_only[0].z},\
			// 				(t_fdot_3d){0, 0, poly->dots_rotz_only[0].z}) ||
			if (poly->dots_rotz_only[0].z == -player->height / 2)
			if (poly->dots[0].z == -player->height)
		// 		is_in_poly(poly, fdot_3d_sub((t_fdot_3d){0, 0, delta}, poly->dots_rotz_only[0]),\
		// 						fdot_3d_sub((t_fdot_3d){0, 0, delta}, poly->dots_rotz_only[0])) ? 1 : 0);
		poly = poly->next;
		if (is_intersection_cercle_segment(poly->dots_rotz_only[i], poly->dots_rotz_only[i ? i - 1 : N_DOTS_POLY], radius))
		poly = poly->next;
		if (!(poly->next = (t_poly *)malloc(sizeof(t_poly))))
		poly = poly->next;
	poly->next = NULL;
	while (++i < poly->n_proj)
		i2 = i ? i - 1 : poly->n_proj - 1;
		if ((poly->dots_proj[i].y == y &&\
			(0 <= poly->dots_proj[i].x && poly->dots_proj[i].x <= x)) ||\
			(poly->dots_proj[i2].y == y &&\
			(0 <= poly->dots_proj[i2].x && poly->dots_proj[i2].x <= x)))
		else if (is_intersection(poly->dots_proj[i], poly->dots_proj[i2], x, y))
			// 	printf("\td1 %d %d\t\td2 %d %d\t\t%d\n", poly->dots_proj[i].x, poly->dots_proj[i].y, poly->dots_proj[i2].x, poly->dots_proj[i2].y, 1);
		// 	printf("\td1 %d %d\t\td2 %d %d\t\t%d\n", poly->dots_proj[i].x, poly->dots_proj[i].y, poly->dots_proj[i2].x, poly->dots_proj[i2].y, 0);
	// 	printf("%d %d : n edge %d with poly %p nproj %d\n", x, y, count, poly, poly->n_proj);
		poly = poly->next;
// 		rotate_dot(&(poly->equation.v), matrix);
// 		rotate_dot(&(poly->dots[0]), matrix);
// 		rotate_dot(&(poly->dots[1]), matrix);
// 		rotate_dot(&(poly->dots[2]), matrix);
// 		rotate_dot(&(poly->dots[3]), matrix);
// 		poly->i = (t_fdot_3d){	poly->dots[1].x - poly->dots[0].x,\
// 								poly->dots[1].y - poly->dots[0].y,\
// 								poly->dots[1].z - poly->dots[0].z};
// 		poly->j = (t_fdot_3d){	poly->dots[N_DOTS_POLY - 1].x - poly->dots[0].x,\
// 								poly->dots[N_DOTS_POLY - 1].y - poly->dots[0].y,\
// 								poly->dots[N_DOTS_POLY - 1].z - poly->dots[0].z};
// 		// poly->i = (t_fdot_3d){	poly->dots[0].x - poly->dots[1].x,\
// 		// 						poly->dots[0].y - poly->dots[1].y,\
// 		// 						poly->dots[0].z - poly->dots[1].z};
// 		// poly->j = (t_fdot_3d){	poly->dots[0].x - poly->dots[N_DOTS_POLY - 1].x,\
// 		// 						poly->dots[0].y - poly->dots[N_DOTS_POLY - 1].y,\
// 		// 						poly->dots[0].z - poly->dots[N_DOTS_POLY - 1].z};
// 		poly = poly->next;
		poly->equation_rotz_only.v = return_rotate_dot(poly->equation_rotz_only.v, matrix);
		poly->dots_rotz_only[0] = return_rotate_dot(poly->dots_rotz_only[0], matrix);
		poly->dots_rotz_only[1] = return_rotate_dot(poly->dots_rotz_only[1], matrix);
		poly->dots_rotz_only[2] = return_rotate_dot(poly->dots_rotz_only[2], matrix);
		poly->dots_rotz_only[3] = return_rotate_dot(poly->dots_rotz_only[3], matrix);
		poly->i = (t_fdot_3d){	poly->dots_rotz_only[1].x - poly->dots_rotz_only[0].x,\
								poly->dots_rotz_only[1].y - poly->dots_rotz_only[0].y,\
								poly->dots_rotz_only[1].z - poly->dots_rotz_only[0].z};
		poly->j = (t_fdot_3d){	poly->dots_rotz_only[N_DOTS_POLY - 1].x - poly->dots_rotz_only[0].x,\
								poly->dots_rotz_only[N_DOTS_POLY - 1].y - poly->dots_rotz_only[0].y,\
								poly->dots_rotz_only[N_DOTS_POLY - 1].z - poly->dots_rotz_only[0].z};
		poly->ii = poly->i.x * poly->i.x + poly->i.y * poly->i.y + poly->i.z * poly->i.z;
		poly->jj = poly->j.x * poly->j.x + poly->j.y * poly->j.y + poly->j.z * poly->j.z;
		poly->ijij_iijj = -poly->ii * poly->jj;
		poly = poly->next;
		poly->equation.v = return_rotate_dot(poly->equation_rotz_only.v, matrix);
		poly->equation.d = poly->equation_rotz_only.d;
		poly->dots[0] = return_rotate_dot(poly->dots_rotz_only[0], matrix);
		poly->dots[1] = return_rotate_dot(poly->dots_rotz_only[1], matrix);
		poly->dots[2] = return_rotate_dot(poly->dots_rotz_only[2], matrix);
		poly->dots[3] = return_rotate_dot(poly->dots_rotz_only[3], matrix);
		poly->i = (t_fdot_3d){	poly->dots[1].x - poly->dots[0].x,\
								poly->dots[1].y - poly->dots[0].y,\
								poly->dots[1].z - poly->dots[0].z};
		poly->j = (t_fdot_3d){	poly->dots[N_DOTS_POLY - 1].x - poly->dots[0].x,\
								poly->dots[N_DOTS_POLY - 1].y - poly->dots[0].y,\
								poly->dots[N_DOTS_POLY - 1].z - poly->dots[0].z};
		poly->ii = poly->i.x * poly->i.x + poly->i.y * poly->i.y + poly->i.z * poly->i.z;
		poly->jj = poly->j.x * poly->j.x + poly->j.y * poly->j.y + poly->j.z * poly->j.z;
		poly->ijij_iijj = -poly->ii * poly->jj;
		poly = poly->next;
		translate_dot(&(poly->dots[0]), translation);
		translate_dot(&(poly->dots[1]), translation);
		translate_dot(&(poly->dots[2]), translation);
		translate_dot(&(poly->dots[3]), translation);
		poly->equation.d = -(poly->equation.v.x * poly->dots[0].x + poly->equation.v.y * poly->dots[0].y + poly->equation.v.z * poly->dots[0].z);
		poly = poly->next;
		translate_dot(&(poly->dots_rotz_only[0]), translation);
		translate_dot(&(poly->dots_rotz_only[1]), translation);
		translate_dot(&(poly->dots_rotz_only[2]), translation);
		translate_dot(&(poly->dots_rotz_only[3]), translation);
		poly->equation_rotz_only.d = -(poly->equation_rotz_only.v.x * poly->dots_rotz_only[0].x + poly->equation_rotz_only.v.y * poly->dots_rotz_only[0].y + poly->equation_rotz_only.v.z * poly->dots_rotz_only[0].z);
		poly = poly->next;
			printf("D%d (%f, %f, %f)\n", i, poly->dots[i].x, poly->dots[i].y, poly->dots[i].z);
			printf("D%d (%f, %f, %f)\n", i, poly->dots_rotz_only[i].x, poly->dots_rotz_only[i].y, poly->dots_rotz_only[i].z);
		while (++i < poly->n_dot)
			printf("D%d (%f, %f, %f)\n", i, poly->dots_new[i].x, poly->dots_new[i].y, poly->dots_new[i].z);
		while (++i < poly->n_proj)
			printf("D%d (%d, %d)\n", i, poly->dots_proj[i].x, poly->dots_proj[i].y);
	while (++i < poly->n_proj)
		i2 = i ? i - 1 : poly->n_proj - 1;
				// intersection_segment_edge(win, poly->dots_proj[tmp_n_proj++], proj[i], proj[i2], 0);
				poly->dots_proj[tmp_n_proj++] = intersection_segment_edge(win, proj[i], proj[i2], 0);
				// printf("Create new proj on edge up %d %d\n", poly->dots_proj[tmp_n_proj - 1].x, poly->dots_proj[poly->n_dot - 1].y);
			poly->dots_proj[tmp_n_proj++] = proj[i];
			// intersection_segment_edge(win, poly->dots_proj[tmp_n_proj++], proj[i], proj[i2], 0);
			poly->dots_proj[tmp_n_proj++] = intersection_segment_edge(win, proj[i], proj[i2], 0);
			// printf("Create new proj on edge up %d %d\n", poly->dots_proj[tmp_n_proj - 1].x, poly->dots_proj[poly->n_dot - 1].y);
	poly->n_proj = tmp_n_proj;
	while (++i < poly->n_proj)
		i2 = i ? i - 1 : poly->n_proj - 1;
				// intersection_segment_edge(win, poly->dots_proj[tmp_n_proj++], proj[i], proj[i2], 1);
				poly->dots_proj[tmp_n_proj++] = intersection_segment_edge(win, proj[i], proj[i2], 1);
				// printf("Create new proj on edge right %d %d\n", poly->dots_proj[tmp_n_proj - 1].x, poly->dots_proj[poly->n_dot - 1].y);
			poly->dots_proj[tmp_n_proj++] = proj[i];
			// intersection_segment_edge(win, poly->dots_proj[tmp_n_proj++], proj[i], proj[i2], 1);
			poly->dots_proj[tmp_n_proj++] = intersection_segment_edge(win, proj[i], proj[i2], 1);
			// printf("Create new proj on edge right %d %d\n", poly->dots_proj[tmp_n_proj - 1].x, poly->dots_proj[poly->n_dot - 1].y);
	poly->n_proj = tmp_n_proj;
	while (++i < poly->n_proj)
		i2 = i ? i - 1 : poly->n_proj - 1;
				//intersection_segment_edge(win, poly->dots_proj[tmp_n_proj++], proj[i], proj[i2], 2);
				poly->dots_proj[tmp_n_proj++] = intersection_segment_edge(win, proj[i], proj[i2], 2);
				// printf("Create new proj on edge down %d %d\n", poly->dots_proj[tmp_n_proj - 1].x, poly->dots_proj[poly->n_dot - 1].y);
			poly->dots_proj[tmp_n_proj++] = proj[i];
			// intersection_segment_edge(win, poly->dots_proj[tmp_n_proj++], proj[i], proj[i2], 2);
			poly->dots_proj[tmp_n_proj++] = intersection_segment_edge(win, proj[i], proj[i2], 2);
			// printf("Create new proj on edge down %d %d\n", poly->dots_proj[tmp_n_proj - 1].x, poly->dots_proj[poly->n_dot - 1].y);
	poly->n_proj = tmp_n_proj;
	while (++i < poly->n_proj)
		i2 = i ? i - 1 : poly->n_proj - 1;
				// intersection_segment_edge(win, poly->dots_proj[tmp_n_proj++], proj[i], proj[i2], 3);
				poly->dots_proj[tmp_n_proj++] = intersection_segment_edge(win, proj[i], proj[i2], 3);
				// printf("Create new proj on edge left %d %d\n", poly->dots_proj[tmp_n_proj - 1].x, poly->dots_proj[poly->n_dot - 1].y);
			poly->dots_proj[tmp_n_proj++] = proj[i];
			// intersection_segment_edge(win, poly->dots_proj[tmp_n_proj++], proj[i], proj[i2], 3);
			poly->dots_proj[tmp_n_proj++] = intersection_segment_edge(win, proj[i], proj[i2], 3);
			// printf("Create new proj on edge left %d %d\n", poly->dots_proj[tmp_n_proj - 1].x, poly->dots_proj[poly->n_dot - 1].y);
	poly->n_proj = tmp_n_proj;
	// printf("%p -- %p\n", &proj, &(poly->dots_proj));
	// 	// proj[i] = poly->dots_proj[i];
	// 	printf("%d %d --- %d %d\n", proj[i].x, proj[i].y, poly->dots_proj[i].x, poly->dots_proj[i].y);
	// 	// printf("%p -- %p\n", &(proj[i]), &(poly->dots_proj[i]));
	ft_memcpy(proj, poly->dots_proj, sizeof(t_dot) * N_DOTS_POLY * 2);
	ft_memcpy(proj, poly->dots_proj, sizeof(t_dot) * N_DOTS_POLY * 2);
	ft_memcpy(proj, poly->dots_proj, sizeof(t_dot) * N_DOTS_POLY * 2);
	ft_memcpy(proj, poly->dots_proj, sizeof(t_dot) * N_DOTS_POLY * 2);
		while (++i < poly->n_proj)
			draw_line(win, poly->dots_proj[i], poly->dots_proj[i ? i - 1 : poly->n_proj - 1]);
		poly = poly->next;
		draw_line(win, (t_dot){poly->box_x.x, poly->box_y.x}, (t_dot){poly->box_x.y, poly->box_y.x});
		draw_line(win, (t_dot){poly->box_x.x, poly->box_y.x}, (t_dot){poly->box_x.x, poly->box_y.y});
		draw_line(win, (t_dot){poly->box_x.y, poly->box_y.x}, (t_dot){poly->box_x.y, poly->box_y.y});
		draw_line(win, (t_dot){poly->box_x.x, poly->box_y.y}, (t_dot){poly->box_x.y, poly->box_y.y});
		poly = poly->next;
	while (++i < poly->n_proj)
	while (++i < poly->n_dot)
		poly->dots_proj[i].x = (win->map->player.fov_2 + poly->dots_new[i].y / poly->dots_new[i].x) * win->w_div_fov;
		poly->dots_proj[i].y = (win->map->player.fov_up_2 - poly->dots_new[i].z / poly->dots_new[i].x) * win->h_div_fov;
		// printf("Proj 2d %d %d of 3d dot %f %f %f\n", poly->dots_proj[i].x, poly->dots_proj[i].y, poly->dots_new[i].x, poly->dots_new[i].y , poly->dots_new[i].z);
	poly->n_proj = poly->n_dot;
	poly->n_dot = 0;
		// printf("Dot : %zf %f %f\n", poly->dots[i].x, poly->dots[i].y, poly->dots[i].z);
		if (poly->dots[i].x > 0)
			if (poly->dots[i2].x < 0)
				poly->dots_new[poly->n_dot++] = intersection_axe_y(poly->dots[i], poly->dots[i2]);
				// printf("Create new dot 3d on X %f %f %f\n", poly->dots_new[poly->n_dot - 1].x, poly->dots_new[poly->n_dot - 1].y, poly->dots_new[poly->n_dot - 1].z);
			poly->dots_new[poly->n_dot++] = poly->dots[i];
		else if (poly->dots[i2].x > 0)
			poly->dots_new[poly->n_dot++] = intersection_axe_y(poly->dots[i], poly->dots[i2]);
			// printf("Create new dot 3d on X %f %f %f\n", poly->dots_new[poly->n_dot - 1].x, poly->dots_new[poly->n_dot - 1].y, poly->dots_new[poly->n_dot - 1].z);
		// printf("index %d %d\n", poly->n_dot, i);
		poly->box_x = (t_dot){win->w, 0};
		poly->box_y = (t_dot){win->h, 0};
		set_box(poly, &(poly->box_x), &(poly->box_y), poly->dots_proj);
		// printf("BOX xy %d %d / %d %d\n", poly->box_x.x, poly->box_x.y, poly->box_y.x, poly->box_y.y);
		poly = poly->next;
	coord->x = scalar_product(dot, poly->i) / poly->ii;
	coord->y = scalar_product(dot, poly->j) / poly->jj;
// 	pi = dot.x * poly->i.x + dot.y * poly->i.y + dot.z * poly->i.z;
// 	pj = dot.x * poly->j.x + dot.y * poly->j.y + dot.z * poly->j.z;
// 	if (!(div = poly->ijij_iijj))
// 	coord->x = (-poly->jj * pi) * div;
// 	coord->y = (-poly->ii * pj) * div;
// 	// coord->x = (-poly->jj * pi + poly->ij * pj) * div;
// 	// coord->y = (-poly->ii * pj + poly->ij * pi) * div;
	// find_coord_plan(poly, &coord_plan, (t_fdot_3d){	collision.x - poly->dots[0].x,\
	// 												collision.y - poly->dots[0].y,\
	// 												collision.z - poly->dots[0].z});
	find_coord_plan(poly, &coord_plan, fdot_3d_sub(collision, poly->dots[0]));
		// 	printf("Collision %f %f %f\n", poly->dots[0].x, poly->dots[0].y, poly->dots[0].z);
		// 	printf("i j %f %f %f / %f %f %f\n", poly->i.x, poly->i.y, poly->i.z, poly->j.x, poly->j.y, poly->j.z);
	coord_texture = (t_dot){modulo(coord_plan.x * poly->dist12, poly->texture->w),\
							modulo(coord_plan.y * poly->dist14, poly->texture->h)};
	if (coord_texture.x < 0 || coord_texture.y < 0 || coord_texture.x > poly->texture->w || coord_texture.y > poly->texture->h)
		printf("box %d %d / %d %d\n", poly->box_x.x, poly->box_x.y, poly->box_y.x, poly->box_y.y);
	// printf("color %x\n", ((int *)poly->texture->pixels)[coord_texture.y * poly->texture->w + coord_texture.x]);
	return (((int *)poly->texture->pixels)[coord_texture.y * poly->texture->w + coord_texture.x]);
	if (!intersection_plan_my_ray(&collision, poly->equation, ray))
	y = poly->box_y.x;
	while (++y < poly->box_y.y)
			x = poly->box_x.x;
			while (++x < poly->box_x.y)
			poly = poly->next;
// 	find_coord_plan(&coord_plan, collision, poly->i, poly->j);
// 	coord_texture = (t_dot){modulo(coord_plan.x * poly->dist12, poly->texture->w),\
// 							modulo(coord_plan.y * poly->dist14, poly->texture->h)};
// 	coord_texture = (t_dot){modulo(coord_plan.x * poly->dist12, poly->texture->w),\
// 							modulo(coord_plan.y * poly->dist14, poly->texture->h)};
// 	return (((int *)poly->texture->pixels)[coord_texture.y * poly->texture->w + coord_texture.x]);
// 	if (!intersection_plan_line(&collision, poly->equation, ray))
